<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Графік ціни біткойна</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #121417; /* Дуже темно-сірий/майже чорний фон, як на Binance */
            color: #e0e0e0; /* Світлий текст для темної теми */
        }
        .tooltip {
            position: absolute;
            text-align: left;
            width: auto;
            height: auto;
            padding: 8px;
            font: 12px sans-serif;
            background: #2a2c31; /* Темніший фон для підказки */
            color: white;
            border: 1px solid #444;
            border-radius: 4px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 1000;
        }
        .chart-container {
            position: relative;
            width: 100%;
            padding-bottom: 56.25%; /* Співвідношення сторін 16:9 */
            height: 0;
            overflow: hidden;
            background-color: #1a1c20; /* Темний фон для контейнера графіка */
            border: 1px solid #2a2c31; /* Тонка рамка */
        }
        .chart-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        /* Стилі для осей та сітки */
        .axis line, .axis path {
            stroke: #4a4a4a; /* Тонкі лінії для осей */
            stroke-width: 1;
        }
        .axis text {
            fill: #a0a0a0; /* Світліший текст для міток осей */
            font-size: 11px;
        }
        .grid line {
            stroke: #2a2c31; /* Дуже тонкі лінії сітки */
            stroke-opacity: 0.8;
            shape-rendering: crispEdges;
        }
        /* Стилі для свічок */
        .candle {
            stroke-width: 1;
        }
        .candle.up {
            fill: #0ecb81; /* Зелений для зростання */
            stroke: #0ecb81;
        }
        .candle.down {
            fill: #f6465d; /* Червоний для падіння */
            stroke: #f6465d;
        }
        .wick {
            stroke-width: 1;
        }
        .wick.up {
            stroke: #0ecb81;
        }
        .wick.down {
            stroke: #f6465d;
        }
        .time-period-button {
            @apply px-3 py-1 rounded-md text-sm font-medium transition-colors duration-200;
            @apply bg-gray-700 text-gray-300 hover:bg-gray-600 hover:text-gray-100;
        }
        .time-period-button.active {
            @apply bg-blue-600 text-white;
        }
        .download-button {
            @apply px-4 py-2 rounded-md text-sm font-medium transition-colors duration-200;
            @apply bg-purple-600 text-white hover:bg-purple-700;
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen p-4">
    <div id="main-content-to-capture" class="bg-gray-900 rounded-xl shadow-lg p-6 w-full max-w-4xl border border-gray-700 relative">
        <div class="flex justify-between items-center mb-4">
            <div class="flex items-baseline">
                <span class="text-2xl font-bold text-gray-100 mr-2">BTCUSDT</span>
                <span id="last-price" class="text-xl font-semibold text-green-500">Завантаження...</span>
            </div>
            <div class="text-right">
                <span id="price-change" class="text-lg font-semibold text-gray-400"></span>
            </div>
        </div>

        <div id="control-buttons" class="flex justify-center space-x-2 mb-4">
            <button class="time-period-button" data-days="1">1D</button>
            <button class="time-period-button active" data-days="30">1M</button>
            <button class="time-period-button" data-days="365">1Y</button>
        </div>

        <div class="flex flex-wrap justify-around text-center mt-6 mb-4">
            <div class="flex-1 p-2 bg-gray-800 rounded-lg mx-1 my-1 min-w-[150px]">
                <h3 class="text-sm font-semibold text-gray-300 mb-2">За день</h3>
                <div id="day-report" class="text-left">Завантаження...</div>
            </div>
            <div class="flex-1 p-2 bg-gray-800 rounded-lg mx-1 my-1 min-w-[150px]">
                <h3 class="text-sm font-semibold text-gray-300 mb-2">За місяць</h3>
                <div id="month-report" class="text-left">Завантаження...</div>
            </div>
            <div class="flex-1 p-2 bg-gray-800 rounded-lg mx-1 my-1 min-w-[150px]">
                <h3 class="text-sm font-semibold text-gray-300 mb-2">За рік</h3>
                <div id="year-report" class="text-left">Завантаження...</div>
            </div>
        </div>

        <div id="error-message" class="hidden text-center text-red-500 text-lg mb-4">
            Не вдалося завантажити дані. Спробуйте ще раз пізніше.
        </div>

        <div id="chart-container" class="chart-container rounded-lg overflow-hidden">
            <svg id="bitcoin-chart" class="chart-svg"></svg>
        </div>

        <div class="tooltip" id="tooltip"></div>

        <div class="flex justify-center mt-4">
            <button id="download-chart-button" class="download-button">Завантажити JPG</button>
        </div>

    </div>

    <script>
        // Define margins and dimensions for the chart
        const margin = { top: 20, right: 60, bottom: 40, left: 60 };

        // Set up global variables for Firebase (if needed, though not used in this specific app)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null; 

        // D3.js chart setup
        const svg = d3.select("#bitcoin-chart");
        const tooltip = d3.select("#tooltip");
        // Removed loading message element selection
        // const loading = d3.select("#loading"); 
        const errorMessage = d3.select("#error-message");
        const lastPriceDisplay = d3.select("#last-price");
        const priceChangeDisplay = d3.select("#price-change");
        const timePeriodButtons = d3.selectAll(".time-period-button");
        const downloadButton = d3.select("#download-chart-button"); // Select the new download button
        const controlButtonsContainer = d3.select("#control-buttons"); // Select the container for time period buttons

        // Global D3 scale and axis variables
        let x, y;
        let originalXScale; // To store the initial x-scale for zooming
        let xAxisGroup, yAxisGroup, xGridGroup, yGridGroup;
        let wicks, candles;
        let currentDays = 30; // Default to 1 month

        // Global data variable for the chart
        let chartData = [];

        // Function to update chart dimensions and redraw
        function updateChartDimensions() {
            const container = d3.select("#chart-container");
            const containerWidth = container.node().getBoundingClientRect().width;
            width = containerWidth - margin.left - margin.right;
            height = (containerWidth * 0.5625) - margin.top - margin.bottom;

            svg.attr("width", width + margin.left + margin.right)
               .attr("height", height + margin.top + margin.bottom);

            svg.selectAll("*").remove(); // Clear previous chart elements

            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Initialize axis and grid groups
            xAxisGroup = g.append("g").attr("class", "axis x-axis").attr("transform", `translate(0,${height})`);
            xGridGroup = g.append("g").attr("class", "grid").attr("transform", `translate(0,${height})`);
            yAxisGroup = g.append("g").attr("class", "axis y-axis").attr("transform", `translate(${width},0)`);
            yGridGroup = g.append("g").attr("class", "grid");

            return g;
        }

        // Function to fetch Bitcoin OHLC data (general purpose) with retry logic
        async function fetchBitcoinOHLC(days, retries = 3, delay = 1000) {
            // Removed loading message display logic here
            // if (days === currentDays) {
            //     loading.style("display", "block");
            //     errorMessage.style("display", "none");
            // }

            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(`https://api.coingecko.com/api/v3/coins/bitcoin/ohlc?vs_currency=usd&days=${days}`, {
                        mode: 'cors' // Explicitly set CORS mode
                    });
                    if (!response.ok) {
                        // If it's a 401 or other HTTP error, throw to catch and retry
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const rawData = await response.json();
                    return rawData.map(d => ({
                        date: new Date(d[0]),
                        open: +d[1],
                        high: +d[2],
                        low: +d[3],
                        close: +d[4]
                    })).sort((a, b) => a.date - b.date);
                } catch (error) {
                    console.error(`Помилка завантаження даних біткойна (спроба ${i + 1}/${retries}):`, error);
                    if (i < retries - 1) {
                        // Wait before retrying
                        await new Promise(res => setTimeout(res, delay));
                    } else {
                        // Last retry failed, display error message
                        // Ensure error message still displays if fetch fails for the main chart
                        if (days === currentDays) {
                            // loading.style("display", "none"); // No loading element to hide
                            if (error.message.includes("401")) {
                                errorMessage.html("Не вдалося завантажити дані: Помилка авторизації (401). Можливо, це тимчасова проблема з постачальником даних або обмеження запитів. Спробуйте ще раз пізніше.");
                            } else if (error instanceof TypeError && error.message.includes("Failed to fetch")) {
                                errorMessage.html("Не вдалося завантажити дані: Можливі проблеми з мережею, тимчасова недоступність API або обмеження CORS. Перевірте підключення до Інтернету та консоль браузера на наявність помилок CORS, або спробуйте ще раз пізніше.");
                            } else {
                                errorMessage.text("Не вдалося завантажити дані. Спробуйте ще раз пізніше.");
                            }
                            errorMessage.style("display", "block");
                        }
                        return null;
                    }
                }
            }
            return null; // Should not be reached if retries are handled correctly
        }

        // Zoom handler
        function zoomed(event) {
            const newXScale = event.transform.rescaleX(originalXScale);

            // Update X axis and grid
            xAxisGroup.call(d3.axisBottom(newXScale).tickFormat(d3.timeFormat("%b %d")));
            xGridGroup.call(d3.axisBottom(newXScale).tickSize(-height).tickFormat(""));

            // Calculate dynamic candle width based on visible data points
            const visibleDomain = newXScale.domain();
            const visibleData = chartData.filter(d => d.date >= visibleDomain[0] && d.date <= visibleDomain[1]);

            let currentCandleWidth = 5; // Default pixel width
            if (visibleData.length > 1) {
                // Calculate average pixel distance between visible candles
                const avgPixelDistance = (newXScale(visibleData[visibleData.length - 1].date) - newXScale(visibleData[0].date)) / (visibleData.length - 1);
                currentCandleWidth = Math.max(1, avgPixelDistance * 0.7); // 70% of average distance
            } else if (visibleData.length === 1) {
                currentCandleWidth = 10; // If only one candle visible, give it a reasonable size
            }


            // Update candles and wicks positions and width
            wicks.attr("x1", d => newXScale(d.date))
                 .attr("x2", d => newXScale(d.date));

            candles.attr("x", d => newXScale(d.date) - currentCandleWidth / 2)
                   .attr("width", currentCandleWidth);
        }

        // Function to draw the main candlestick chart
        function drawCandlestickChart(dataToDraw) {
            const g = updateChartDimensions();

            // Define scales for X (time) and Y (price)
            x = d3.scaleTime()
                .domain(d3.extent(dataToDraw, d => d.date))
                .range([0, width]);

            originalXScale = x.copy(); // Store a copy of the initial scale

            y = d3.scaleLinear()
                .domain([d3.min(dataToDraw, d => d.low) * 0.98, d3.max(dataToDraw, d => d.high) * 1.02]) // Add some padding
                .range([height, 0]);

            // Add X grid lines
            xGridGroup.call(d3.axisBottom(x)
                .ticks(d3.timeDay.every(currentDays > 90 ? 30 : (currentDays > 30 ? 10 : 5))) // Adjust ticks based on period
                .tickSize(-height)
                .tickFormat("")
            );

            // Add Y grid lines
            yGridGroup.call(d3.axisLeft(y)
                .tickSize(-width)
                .tickFormat("")
            );

            // Add the X axis
            xAxisGroup.call(d3.axisBottom(x)
                .ticks(d3.timeDay.every(currentDays > 90 ? 30 : (currentDays > 30 ? 10 : 5))) // Adjust ticks based on period
                .tickFormat(d3.timeFormat("%b %d"))
            )
            .selectAll("text")
            .attr("class", "text-gray-400 text-sm");

            // Add the Y axis
            yAxisGroup.call(d3.axisRight(y).tickFormat(d3.format("$,.0f"))) // Format as currency, right side
                .selectAll("text")
                .attr("class", "text-gray-400 text-sm");

            // Initial candle width calculation
            const initialCandleWidth = dataToDraw.length > 1 ? (x(dataToDraw[1].date) - x(dataToDraw[0].date)) * 0.7 : 10;

            // Draw wicks (high-low lines)
            wicks = g.selectAll(".wick")
                .data(dataToDraw)
                .enter().append("line")
                .attr("class", d => `wick ${d.close > d.open ? 'up' : 'down'}`)
                .attr("x1", d => x(d.date))
                .attr("x2", d => x(d.date))
                .attr("y1", d => y(d.high))
                .attr("y2", d => y(d.low));

            // Draw candles (open-close rectangles)
            candles = g.selectAll(".candle")
                .data(dataToDraw)
                .enter().append("rect")
                .attr("class", d => `candle ${d.close > d.open ? 'up' : 'down'}`)
                .attr("x", d => x(d.date) - initialCandleWidth / 2)
                .attr("y", d => y(Math.max(d.open, d.close)))
                .attr("width", initialCandleWidth)
                .attr("height", d => Math.abs(y(d.open) - y(d.close)) || 1); // Ensure min height of 1px

            // Update header with last price and change
            const lastDataPoint = dataToDraw[dataToDraw.length - 1];
            const firstDataPoint = dataToDraw[0];
            if (lastDataPoint) {
                lastPriceDisplay.text(`$${d3.format(",.2f")(lastDataPoint.close)}`);
                const change = ((lastDataPoint.close - firstDataPoint.open) / firstDataPoint.open) * 100;
                priceChangeDisplay.text(`${change >= 0 ? '+' : ''}${change.toFixed(2)}%`);
                priceChangeDisplay.classed("text-green-500", change >= 0);
                priceChangeDisplay.classed("text-red-500", change < 0);
            }

            // Define zoom behavior
            const zoomBehavior = d3.zoom()
                .scaleExtent([1, 20]) // Allow zooming 1x to 20x
                .extent([[0, 0], [width, height]])
                .translateExtent([[0, 0], [width, height]])
                .on("zoom", zoomed);

            // Apply zoom behavior to an overlay rectangle
            g.append("rect")
                .attr("class", "zoom-overlay")
                .attr("width", width)
                .attr("height", height)
                .style("fill", "none")
                .style("pointer-events", "all")
                .call(zoomBehavior);

            // Add a responsive overlay for touch/mouse events for tooltip
            g.select(".zoom-overlay")
                .on("mousemove", function(event) {
                    const [mx, my] = d3.pointer(event);
                    const currentTransform = d3.zoomTransform(this);
                    const dateAtMouse = currentTransform.rescaleX(originalXScale).invert(mx);

                    // Find the closest data point by date
                    const bisectDate = d3.bisector(d => d.date).left;
                    const i = bisectDate(dataToDraw, dateAtMouse, 1);
                    const d0 = dataToDraw[i - 1];
                    const d1 = dataToDraw[i];
                    let d = null;

                    if (d0 && d1) {
                        d = dateAtMouse - d0.date > d1.date - dateAtMouse ? d1 : d0;
                    } else if (d0) {
                        d = d0;
                    } else if (d1) {
                        d = d1;
                    }

                    if (d) {
                        tooltip.style("opacity", 1)
                               .html(`
                                   Дата: ${d3.timeFormat("%b %d, %Y")(d.date)}<br/>
                                   Відкриття: ${d3.format("$,.2f")(d.open)}<br/>
                                   Макс: ${d3.format("$,.2f")(d.high)}<br/>
                                   Мін: ${d3.format("$,.2f")(d.low)}<br/>
                                   Закриття: ${d3.format("$,.2f")(d.close)}
                               `)
                               .style("left", (event.pageX + 10) + "px")
                               .style("top", (event.pageY - 28) + "px");
                    } else {
                        tooltip.style("opacity", 0);
                    }
                })
                .on("mouseout", function() {
                    tooltip.style("opacity", 0);
                });
        }

        // Function to update the main chart
        async function updateChart() {
            chartData = await fetchBitcoinOHLC(currentDays);
            if (!chartData) return;
            // Removed loading message display logic here
            // loading.style("display", "none"); 
            drawCandlestickChart(chartData);
        }

        // Function to display report for a given period
        function displayReport(elementId, periodData) {
            const reportElement = d3.select(`#${elementId}`);
            if (!periodData || periodData.length === 0) {
                reportElement.html('<p class="text-gray-500">Дані недоступні.</p>');
                return;
            }

            const firstPoint = periodData[0];
            const lastPoint = periodData[periodData.length - 1];
            const maxPrice = d3.max(periodData, d => d.high);
            const minPrice = d3.min(periodData, d => d.low);

            const openPrice = firstPoint.open;
            const closePrice = lastPoint.close;
            const priceChange = closePrice - openPrice;
            const percentageChange = (priceChange / openPrice) * 100;

            reportElement.html(`
                <div class="flex flex-col items-start">
                    <span class="text-xs text-gray-400">Відкриття: <span class="font-semibold text-gray-200">$${d3.format(",.2f")(openPrice)}</span></span>
                    <span class="text-xs text-gray-400">Закриття: <span class="font-semibold text-gray-200">$${d3.format(",.2f")(closePrice)}</span></span>
                    <span class="text-xs text-gray-400">Макс: <span class="font-semibold text-green-400">$${d3.format(",.2f")(maxPrice)}</span></span>
                    <span class="text-xs text-gray-400">Мін: <span class="font-semibold text-red-400">$${d3.format(",.2f")(minPrice)}</span></span>
                    <span class="text-xs text-gray-400">Зміна:
                        <span class="font-semibold ${percentageChange >= 0 ? 'text-green-500' : 'text-red-500'}">
                            ${priceChange >= 0 ? '+' : ''}${d3.format(",.2f")(priceChange)} (${percentageChange.toFixed(2)}%)
                        </span>
                    </span>
                </div>
            `);
        }

        // Function to update all reports
        async function updateReports() {
            // Fetch data for 1 day, 30 days, 365 days for reports
            const data1D = await fetchBitcoinOHLC(1);
            const data30D = await fetchBitcoinOHLC(30);
            const data365D = await fetchBitcoinOHLC(365);

            displayReport('day-report', data1D);
            displayReport('month-report', data30D);
            displayReport('year-report', data365D);
        }

        // Function to download the chart and reports as a JPG file
        async function downloadChartAsJPG() {
            const elementToCapture = document.getElementById('main-content-to-capture'); // Capture the entire main container
            if (!elementToCapture) {
                console.error("Елемент для захоплення не знайдено.");
                return;
            }

            // Temporarily hide the control buttons and download button before capturing
            controlButtonsContainer.style('display', 'none');
            downloadButton.style('display', 'none'); // Hide the download button itself
            document.body.style.overflow = 'hidden'; // Temporarily hide scrollbars

            try {
                const canvas = await html2canvas(elementToCapture, {
                    scale: 2, // Increase scale for better resolution
                    useCORS: true, // Enable CORS if you're loading images from other domains
                    backgroundColor: '#121417' // Set background color to match body
                });

                // Create a temporary anchor element to trigger the download
                const a = document.createElement('a');
                a.href = canvas.toDataURL('image/jpeg', 0.9); // Convert canvas to JPG with quality 0.9
                a.download = 'bitcoin_chart_and_reports.jpg'; // Default filename
                document.body.appendChild(a); // Append to body
                a.click(); // Programmatically click the anchor to trigger download
                document.body.removeChild(a); // Clean up
            } catch (error) {
                console.error("Помилка при завантаженні JPG:", error);
                alert("Не вдалося завантажити зображення. Спробуйте ще раз."); // Use a simple alert for user feedback
            } finally {
                // Always show the control buttons and download button, and restore scrollbars after capture (even if error)
                controlButtonsContainer.style('display', 'flex');
                downloadButton.style('display', 'block'); // Show the download button again
                document.body.style.overflow = '';
            }
        }

        // Event listeners for time period buttons
        timePeriodButtons.on("click", function() {
            timePeriodButtons.classed("active", false); // Deactivate all buttons
            d3.select(this).classed("active", true); // Activate clicked button
            currentDays = d3.select(this).attr("data-days");
            updateChart(); // Update chart with new period
        });

        // Event listener for the download button
        downloadButton.on("click", downloadChartAsJPG);


        // Initial chart draw and reports load on window load
        window.onload = function() {
            updateChart(); // Initial chart load
            // Add a small delay before updating reports to potentially avoid immediate rate limits
            setTimeout(() => {
                updateReports();
            }, 500); // 500ms delay
            window.addEventListener('resize', updateChart); // Chart resize listener
        };
    </script>
</body>
</html>
